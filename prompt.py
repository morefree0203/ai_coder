from langchain_core.prompts import PromptTemplate

# Research Agent 使用的提示模板常量

SYSTEM_RESEARCH_BASE = """
你是一位专业的研究助手，擅长进行系统性的信息检索和分析。
你的任务是：
1. 分析用户的问题，制定合理的搜索策略
2. 使用网络搜索工具获取相关信息
3. 综合分析搜索结果，提供准确、有见地的回答
4. 在对话过程中保持上下文连贯性

请始终以客观、专业的方式回答问题，确保信息准确可靠。
"""

PLAN_PROMPT = """
基于用户的问题："{query}"

请制定一个信息检索计划，分解为最多 {max_subquestions} 个搜索主题。
每个搜索主题应该：
1. 简洁明了，使用2-5个关键词，不要使用完整的句子
2. 聚焦技术实现，包含关键技术栈名称（如 Spring Boot、REST API、文件上传）
3. 相互补充，避免重复
4. 能够帮助全面回答用户的问题

重要提示：
- 搜索关键词要简洁，例如："Spring Boot 文件上传" 而不是 "如何使用Spring Boot实现文件上传功能"
- 包含技术栈名称，例如："Spring Boot REST API"、"JavaScript 音频播放"、"MySQL 数据库设计"
- 避免使用"如何"、"怎样"等疑问词，直接使用关键词组合

请以 JSON 数组格式返回，格式如下：
[
  {{"subq": "Spring Boot 文件上传 MultipartFile", "reason": "需要了解Spring Boot如何处理文件上传"}},
  {{"subq": "JavaScript Audio API 随机播放", "reason": "需要了解前端如何实现音频随机播放"}}
]

只返回 JSON 数组，不要包含其他文本。
"""

SYNTHESIS_PROMPT = """
基于用户的问题："{query}"

以下是搜索到的信息片段：
{snippets}

请综合这些信息，撰写一个完整、准确的回答。
要求：
1. 直接回答用户的问题
2. 引用相关信息来源
3. 保持逻辑清晰，结构合理
4. 如果信息不足，明确说明
"""

CRITIQUE_PROMPT = """
用户对之前的回答提出了反馈："{feedback}"

请分析用户的反馈，判断是否需要：
1. 进行新的搜索来补充信息
2. 修改或完善现有回答
3. 澄清某些概念

请以 JSON 格式返回：
{{
  "need_new_search": true/false,
  "new_subquestions": ["新搜索问题1", "新搜索问题2"] （如果需要新搜索）,
  "improved_answer": "改进后的完整回答"
}}

如果不需要新搜索，new_subquestions 设为空数组。
"""

MEMORY_SUMMARIZE_PROMPT = """
以下是对话历史记录，请将其压缩为一段简洁的摘要，保留关键信息和上下文。

对话历史：
{history}

请生成一个简洁的摘要，要求：
1. 保留用户的主要问题和研究目标
2. 保留重要的发现和结论
3. 保留关键的技术细节和概念
4. 使用简洁的语言，控制在1000字以内

摘要：
"""

STRUCTURED_COMPRESSION_PROMPT = """
以下是对话历史记录，请将其压缩为结构化的摘要，保留对代码研究有价值的细节。

对话历史：
{history}

请以严格的 JSON 格式输出结构化摘要，包含以下字段（不要输出任何多余文本或代码块标记）：

{{
  "summary": "简短结论（1-3行，概括整个对话的核心内容，包括用户的主要目标和当前进展）",
  "decisions": [
    "已定决策1（例如：使用Spring Boot 3.2.0，包含版本号）",
    "已定决策2（例如：采用前后端分离架构，说明原因）"
  ],
  "open_questions": [
    "仍未解决的问题1（具体描述问题，不要过于抽象）",
    "仍未解决的问题2"
  ],
  "experiments": [
    {{
      "id": "exp_1",
      "description": "实验描述（具体说明做了什么尝试）",
      "outcome": "结果（成功/失败/部分成功，包含关键发现）",
      "error_messages": "错误信息预览（如果有，保留关键错误信息）"
    }}
  ],
  "timeline": [
    "关键事件1（按时间顺序，包含具体时间点或顺序）",
    "关键事件2"
  ],
  "notes": "其他重要备注（包括用户偏好、特殊要求、技术约束等）"
}}

重要提示：
1. **保留所有技术决策和关键假设**：包括框架版本、架构选择、技术选型等，必须具体到版本号
2. **保留错误堆栈和实验步骤的关键信息**：错误信息的前几行、关键配置参数、实验步骤的关键点
3. **保留未解决的问题**：具体描述问题，不要过于抽象，便于后续继续研究
4. **保留用户偏好和约束**：如性能要求、成本限制、技术栈偏好等
5. **保留关键代码片段的位置信息**：如果提到特定文件或函数，保留这些信息
6. **时间线要具体**：包含关键事件的发生顺序和重要时间点
7. 如果某个字段没有内容，使用空数组 [] 或 null
8. 不要输出 ```json 代码块标记，直接输出纯 JSON 字符串
9. 确保所有字段都有值，不要留空
10. **摘要要包含上下文**：说明这些对话的背景和目的，便于后续理解
"""

# 更激进的压缩提示词（当上下文接近限制时使用，但保留足够的关键信息）
AGGRESSIVE_COMPRESSION_PROMPT = """
以下是对话历史记录，由于上下文长度限制，需要将其压缩为更简洁的结构化摘要，在减少token数的同时尽可能保留关键信息。

对话历史：
{history}

请以严格的 JSON 格式输出压缩后的结构化摘要，包含以下字段（不要输出任何多余文本或代码块标记）：

{{
  "summary": "简短结论（3-5行，概括整个对话的核心内容，包括用户的主要目标、关键进展和当前状态）",
  "decisions": [
    "已定决策1（保留重要的技术决策，包含版本号和关键配置）",
    "已定决策2"
  ],
  "open_questions": [
    "未解决问题1（保留重要的未解决问题和待办事项）"
  ],
  "experiments": [
    {{
      "id": "exp_1",
      "description": "实验描述（简洁但完整的描述做了什么尝试）",
      "outcome": "结果（简洁但包含关键发现和结论）",
      "error_messages": "错误信息（如果有，保留关键错误和解决方案）"
    }}
  ],
  "timeline": [
    "关键事件1（保留重要的时间点和关键步骤）"
  ],
  "notes": "其他重要备注（保留用户偏好、技术约束、性能要求等）"
}}

重要提示：
1. **平衡压缩**：在减少token数的同时，尽可能保留对后续对话有价值的信息
2. **优先保留**：技术决策（含版本号）> 关键进展 > 未解决问题 > 错误信息 > 用户偏好
3. **适度合并**：只合并完全重复的内容，保留相似但有区别的信息
4. **删除冗余**：删除重复、过于详细或不太重要的信息，但保留技术细节
5. **摘要要简洁但完整**：控制在300-500字，清晰说明核心目标、关键进展和当前状态
6. **决策保留10-15条**：保留所有重要的技术决策，包括版本号、架构选择、关键配置等
7. **问题保留5-8条**：保留所有重要的未解决问题和待办事项
8. **实验保留5-8个**：保留重要的实验记录，包括尝试的方法和关键发现
9. **时间线保留关键点**：保留重要的时间节点和关键步骤，但可以合并相似事件
10. 如果某个字段没有内容，使用空数组 [] 或 null
11. 不要输出 ```json 代码块标记，直接输出纯 JSON 字符串
12. **保留上下文连贯性**：确保压缩后的内容仍然能够支持后续对话的连贯性
"""

RESEARCH_PROMPT = PromptTemplate(
    input_variables=["requirement", "research_data", "previous_plan", "instruction"],
    template="""
你是一位高级系统架构师。基于以下调研数据，请生成一份详细的技术方案。

---用户需求---
{requirement}

--- 之前的方案/记录---
{previous_plan}

注意：如果存在上一次的技术方案，请基于该方案进行改进和完善，而不是完全重写。
- 保留原有方案中合理的部分
- 根据用户的新需求或反馈进行调整
- 如果用户要求修改某些技术选型，请说明修改原因并保持整体架构的一致性

---调研数据---
{research_data}

注意：调研数据中包含了每个搜索结果的URL和对应的内容。**在调研数据的开头，已经列出了所有可用的参考文献URL列表（带编号）**。在生成报告时，你需要：
1. **参考文献来源规则**：
   - **优先使用调研数据开头的URL列表中的URL**（这些是搜索或fetch到的实际URL）
   - **如果URL列表中没有足够的相关URL，可以使用你已知的官方文档URL**（如Spring Boot官方文档、Vue.js官方文档、MySQL官方文档等）
   - **可以使用你已知的标准规范、最佳实践指南的官方URL**（如RESTful API规范、HTTP标准、OWASP安全指南等）
   - **禁止编造不存在的URL**，只能使用真实存在的官方文档、标准规范、技术社区等URL
   - **所有URL必须与用户需求（{requirement}）相关**，不能添加与用户需求无关的URL
   - **如果URL列表中没有足够的相关URL，不要为了满足数量要求而添加不相关的URL**。优先保证质量而非数量
2. 在详细描述中使用引用标注，如 [1]、[2] 等
3. 在 references 数组中列出所有引用的URL，索引从1开始对应引用标注
   **重要约束（必须严格遵守）**：
   - **一致性约束**：
     * references 数组的长度必须等于正文中使用的最大引用编号（例如：如果正文中最大引用编号是 [34]，则 references 数组必须有且仅有 34 个元素）
     * 如果正文中只使用了 [1] 到 [N]，则 references 数组必须只有 N 个元素，不能包含更多
     * 正文中绝对不能使用超出 references 数组范围的引用标注（例如：如果 references 只有 39 个元素，正文中绝对不能使用 [40]、[53]、[74]、[96]、[98] 或更大的编号）
   - **相关性约束**：
     * 每个引用标注对应的参考文献URL必须与引用位置的正文内容高度相关，不能为了凑数而添加不相关的引用
     * 在添加引用标注前，必须确认该URL的内容确实与引用位置的正文内容相关（例如：如果正文提到"Spring Boot"，引用的URL必须与Spring Boot相关）
     * 禁止为了满足数量要求而添加与正文内容无关的引用
4. **references 数组中的URL必须满足以下要求**：
   - 建议包含20-50个不同的URL（根据实际URL列表中的相关URL数量调整），涵盖各个技术栈的官方文档、最佳实践、性能指南、安全指南、部署方案、设计模式、架构模式等各个方面
   - **引用来源应高度多样化且优先级平等，包括但不限于**：
     - **通用技术社区**：CSDN、掘金、博客园、思否（SegmentFault）、开源中国、V2EX
     - **知识问答平台**：知乎技术专栏（适合技术选型、趋势分析、架构设计思考）、Stack Overflow中文讨论
     - **大厂技术门户**：阿里技术、腾讯技术、字节跳动技术、美团技术、京东技术等（适合大规模分布式系统、高并发、AI/数据技术等实战经验）
     - **云平台文档**：阿里云、腾讯云、华为云、百度智能云等（适合云原生、Kubernetes、数据库服务、中间件等基础设施）
     - **代码托管平台**：GitHub、Gitee（码云）、GitCode（适合开源项目、实战代码、本地化解决方案）
     - **垂直领域社区**：Go语言中文网、Rust CN社区、Python之家、Vue.js中文社区、React中文社区等（适合特定语言/框架的深度研究和最佳实践）
     - **官方文档、技术博客、最佳实践指南等**
   **所有来源优先级平等，优先选择内容质量高、实战经验丰富且与用户需求相关的文章，这些平台上的实战经验和本地化最佳实践非常有价值**

---重要说明---
{instruction}

---输出要求---
请输出严格的 JSON 格式，包含以下字段（不要输出任何多余文本或代码块）：

{{
  "project_name": "项目名称（简洁明了）",
  "description": "项目的详细描述，包括项目目标、核心功能、应用场景等（200-500字）",
  "keywords": ["关键词1", "关键词2", "关键词3", ...],
  "tech_stack": {{
    "language": "主要编程语言及版本（如：Java 17, Python 3.11, TypeScript 5.0）",
    "backend": {{
      "framework": "后端框架及版本（如：Spring Boot 3.2.0, Django 4.2, Express.js 4.18）。**如果项目没有后端，设为null**",
      "orm": "ORM框架（如：MyBatis-Plus 3.5.0, Hibernate 6.0, Sequelize 6.32）。**如果项目不使用ORM或没有数据库，设为null**",
      "authentication": "认证授权方案（如：JWT, Spring Security, OAuth2）。**如果项目不需要用户登录认证，设为null**",
      "api": "API相关技术（如：RESTful API, GraphQL, gRPC）。**如果项目没有API接口，设为null**",
      "other": ["其他后端技术1", "其他后端技术2"]  // **如果项目没有其他后端技术，设为空数组 []，不要强行添加不需要的技术**
    }},
    "frontend": {{
      "framework": "前端框架及版本（如：Vue 3.3.0, React 18.2, Angular 16.0）。**如果项目使用原生JavaScript或没有前端框架，设为null**",
      "ui_library": "UI组件库（如：Element Plus, Ant Design Vue, Material-UI）。**如果项目不使用UI组件库，设为null**",
      "state_management": "状态管理（如：Vuex, Pinia, Redux）。**如果项目不使用状态管理库，设为null**",
      "build_tool": "构建工具（如：Vite 5.0, Webpack 5.0）。**如果项目不使用构建工具，设为null**",
      "other": ["其他前端技术1", "其他前端技术2"]  // **如果项目没有其他前端技术，设为空数组 []，不要强行添加不需要的技术**
    }},
    "database": {{
      "primary": "主数据库及版本（如：MySQL 8.0, PostgreSQL 15.0, MongoDB 7.0）。**如果项目不使用数据库，设为null**",
      "cache": "缓存数据库（如：Redis 7.0, Memcached）。**如果项目不使用缓存，设为null**",
      "other": ["其他数据库技术1", "其他数据库技术2"]  // **如果项目没有其他数据库技术，设为空数组 []，不要强行添加不需要的技术（如：不使用消息队列就不要添加）**
    }},
    "devops": {{
      "container": "容器技术（如：Docker, Kubernetes）。**如果项目不使用容器化，设为null**",
      "ci_cd": "CI/CD工具（如：Jenkins, GitLab CI, GitHub Actions）。**如果项目不使用CI/CD，设为null**",
      "monitoring": "监控工具（如：Prometheus, Grafana）。**如果项目不使用监控工具，设为null**",
      "other": ["其他DevOps技术1", "其他DevOps技术2"]  // **如果项目没有其他DevOps技术，设为空数组 []，不要强行添加不需要的技术（如：不使用消息队列、负载均衡器等就不要添加）**
    }},
    "other": ["其他技术栈1", "其他技术栈2"]  // **如果项目没有其他技术栈，设为空数组 []，不要强行添加不需要的技术**
  }},
  "design_philosophy": "核心架构与设计理念的详细文字描述（根据实际内容决定长度，通常800-1200字）。必须包含：1) 架构模式选择的原因；2) 每个主要技术选型的理由；3) 设计决策的权衡考虑（性能、可维护性、开发效率、成本等）。采用'首先...其次...再次...最后...'的结构，阐述设计思路、技术选型原因、用户体验考虑等。在描述中必须使用引用标注，如 [1]、[2] 等，对应 references 数组中的索引（从1开始）。每个引用标注都应该有对应的URL在 references 中。**为每个主要技术选型、架构模式、设计决策添加引用标注，内容越详细，引用就应该越多。但必须确保每个引用标注对应的参考文献URL与引用位置的正文内容相关，不能为了凑数而添加不相关的引用。**在描述中，所有技术名称、框架名称、方法名、配置项、技术术语等都必须用反引号包裹，例如：选择 `Spring Boot 3.2.0` 作为后端框架，使用 `MyBatis-Plus 3.5.0` 作为 ORM 层。",
  "architecture": {{
    "pattern": "架构模式（如：MVC, MVVM, 微服务架构, 单体架构, 前后端分离）",
    "pattern_reason": "为什么选择这个架构模式（说明选择理由，如开发效率、可维护性、扩展性等）",
    "layers": {{
      "presentation": "表现层描述（前端如何组织，路由结构等）",
      "business": "业务层描述（后端服务如何组织，模块划分等）",
      "data": "数据层描述（数据库设计，数据访问方式等）"
    }},
    "deployment": "部署架构描述（服务器部署方式，负载均衡，高可用方案等）",
    "diagram_description": "架构图文字描述（简要说明各组件之间的关系和数据流向）"
  }},
  "non_functional_requirements": {{
    "performance": "性能要求描述（响应时间、吞吐量、并发处理能力等，如：API响应时间<200ms，支持1000并发用户。包含引用标注，如 [20]、[21] 等）。**重要：在描述中，所有技术术语、指标、工具名称等都必须用反引号包裹。**",
    "scalability": "可扩展性要求描述（水平扩展、垂直扩展策略，如：支持动态扩容，可扩展到10个实例。包含引用标注，如 [22]、[23] 等）。**重要：在描述中，所有技术术语、策略名称等都必须用反引号包裹。**",
    "availability": "可用性要求描述（系统可用性目标、容错机制、故障恢复策略，如：99.9%可用性，自动故障转移。包含引用标注，如 [24]、[25] 等）。**重要：在描述中，所有技术术语、机制名称等都必须用反引号包裹。**",
    "maintainability": "可维护性要求描述（代码规范、文档要求、日志监控等，如：遵循RESTful规范，完整的API文档，结构化日志。包含引用标注，如 [26]、[27] 等）。**重要：在描述中，所有规范名称、工具名称等都必须用反引号包裹。**",
    "reliability": "可靠性要求描述（数据一致性、事务处理、错误处理机制等，如：ACID事务保证，完善的异常处理。包含引用标注，如 [28]、[29] 等）。**重要：在描述中，所有技术术语、机制名称等都必须用反引号包裹。**",
    "usability": "易用性要求描述（用户体验、界面友好性、操作便捷性等，如：响应式设计，直观的操作界面。包含引用标注，如 [30] 等）。**重要：在描述中，所有技术术语、设计模式名称等都必须用反引号包裹。**"
  }},
  "security_design": {{
    "authentication": "认证机制描述（如果项目需要用户登录认证，则详细描述认证方式，如：JWT Token认证、OAuth2、Session认证等，包含实现细节和引用标注，如 [33]、[34] 等。**如果项目不需要登录认证（如：单机工具、公开访问的应用），则明确说明原因，设为null**，如：本项目无需用户登录，故不涉及认证机制）。**重要：在描述中，所有认证方式、技术名称、配置项等都必须用反引号包裹，例如：使用 `JWT Token` 认证，Token有效期24小时，使用 `HS256` 算法签名。**",
    "authorization": "授权机制描述（如果项目需要权限控制，则详细描述权限控制策略，如：RBAC角色权限、API权限控制、数据权限隔离等，包含实现细节和引用标注，如 [35]、[36] 等。**如果项目不需要权限控制，则明确说明原因，设为null**）。**重要：在描述中，所有权限模型、策略名称、技术术语等都必须用反引号包裹。**",
    "data_security": "数据安全描述（数据加密、敏感信息保护、数据脱敏等，如：HTTPS传输加密、数据库字段加密、密码哈希存储等，包含引用标注，如 [37]、[38] 等）。**重要：在描述中，所有加密算法、协议名称、技术术语等都必须用反引号包裹，例如：使用 `HTTPS` 传输加密，采用 `AES-256` 加密算法。**",
    "api_security": "API安全描述（API防护措施，如：请求限流、参数校验、SQL注入防护、XSS防护、CSRF防护等，包含引用标注，如 [39]、[40] 等）。**重要：在描述中，所有安全措施、攻击类型、防护技术等都必须用反引号包裹，例如：防护 `SQL注入` 攻击，使用 `XSS` 过滤。**",
    "infrastructure_security": "基础设施安全描述（服务器安全、网络安全、容器安全等，如：防火墙配置、安全组规则、容器镜像扫描等，包含引用标注，如 [41]、[42] 等）。**重要：在描述中，所有安全工具、配置项、技术术语等都必须用反引号包裹。**",
    "compliance": "合规性要求描述（如：GDPR合规、数据隐私保护、审计日志等，如果适用则描述并包含引用标注，否则为null）。**重要：在描述中，所有合规标准、法规名称等都必须用反引号包裹。**"
  }},
  "module_implementation": "核心功能模块实现的详细文字描述（根据实际内容决定长度，通常800-1500字）。详细描述各个功能模块的实现方式、技术细节、关键代码思路等。每个模块的描述中都要包含引用标注，如 [16]、[17] 等，对应 references 数组中的索引。引用标注应该指向相关的技术文档URL。**为每个功能模块、实现细节、API设计添加引用标注，内容越详细，引用就应该越多。但必须确保每个引用标注对应的参考文献URL与引用位置的正文内容相关，不能为了凑数而添加不相关的引用。**在描述中，所有代码片段、HTML标签、方法名、API路径、类名、配置项、技术术语等都必须用反引号包裹，例如：使用 `<input type='file' accept='audio/*'>` 限制文件类型，通过 `FormData` 封装数据并调用 `fetch` 发送 POST 请求至 `/api/songs/upload`。后端 Controller 使用 `@RequestParam("file") MultipartFile file` 接收文件，调用 `isEmpty()` 判断是否为空。",
  "architecture_details": "系统架构详解的详细文字描述（根据实际内容决定长度，通常600-1500字）。深入阐述前后端分离架构、数据存储架构、部署架构的设计思路和实现细节。包含引用标注，如 [31]、[32] 等，对应 references 数组中的索引。**为每个架构层面的设计、组件选择添加引用标注，内容越详细，引用就应该越多。但必须确保每个引用标注对应的参考文献URL与引用位置的正文内容相关，不能为了凑数而添加不相关的引用。**在描述中，所有技术名称、架构模式、组件名称、路径、配置项等都必须用反引号包裹。",
  "api_design": "API接口详细设计规范（根据实际内容决定长度，通常600-1000字）。详细描述所有RESTful API接口的路径、请求方法、请求参数、响应格式、状态码、错误处理等。包含接口设计规范、参数校验规则、响应格式标准等。**为每个API接口、设计规范添加引用标注，内容越详细，引用就应该越多。但必须确保每个引用标注对应的参考文献URL与引用位置的正文内容相关，不能为了凑数而添加不相关的引用。**在描述中，所有API路径、HTTP方法、参数名、状态码、技术术语等都必须用反引号包裹，例如：`GET /api/songs` 接口返回所有歌曲列表",
  "database_design": "数据库详细设计（根据实际内容决定长度，通常800-1200字）。必须详细描述以下内容：1) 每个数据库表的完整表结构设计，包括表名、字段名、数据类型、长度、是否允许为空、默认值、主键、外键、唯一约束等；2) 每个字段的详细说明，包括字段用途、数据范围、业务含义等；3) 索引设计，包括主键索引、唯一索引、普通索引的设计理由和性能考虑；4) 表之间的关系设计（如果有多个表）；5) 数据字典，列出所有表和字段的完整定义。**必须包含完整的建表SQL语句示例**，展示表结构定义。**为每个表设计、字段设计、索引设计添加引用标注，内容越详细，引用就应该越多。但必须确保每个引用标注对应的参考文献URL与引用位置的正文内容相关，不能为了凑数而添加不相关的引用。**在描述中，所有表名、字段名、数据类型、约束条件、SQL关键字等都必须用反引号包裹，例如：`song_info` 表包含 `id BIGINT AUTO_INCREMENT PRIMARY KEY`、`originalName VARCHAR(255)`、`storedName VARCHAR(255) NOT NULL` 等字段。",
  "error_handling": "错误处理与异常设计（根据实际内容决定长度，通常600-1000字）。必须详细描述以下内容：1) 全局异常处理器设计，包括如何统一捕获和处理异常；2) 异常分类体系，包括业务异常、系统异常、参数校验异常等的分类标准；3) 错误码设计规范，包括错误码的编码规则、错误码与错误信息的映射关系；4) 错误响应格式标准，包括统一的错误响应JSON结构（如：`{{\"code\": 400, \"message\": \"错误信息\", \"data\": null}}`）；5) 常见错误场景的处理策略，包括文件上传失败、数据库操作失败、参数校验失败等的处理方式；6) 日志记录策略，包括异常日志的级别、格式、记录内容等。**必须包含错误码表或错误响应格式示例**。**为每个错误处理机制、异常设计添加引用标注，内容越详细，引用就应该越多。但必须确保每个引用标注对应的参考文献URL与引用位置的正文内容相关，不能为了凑数而添加不相关的引用。**在描述中，所有异常类名、方法名、错误码、配置项等都必须用反引号包裹，例如：使用 `@ControllerAdvice` 注解创建全局异常处理器，定义 `ApiException` 自定义异常类。",
  "testing_strategy": "测试策略与方案（根据实际内容决定长度，通常400-600字）。详细描述单元测试、集成测试、端到端测试的策略和方法。包含测试框架选择、测试覆盖率要求、测试用例设计思路、Mock策略等。**为每个测试策略、测试框架选择添加引用标注，内容越详细，引用就应该越多。但必须确保每个引用标注对应的参考文献URL与引用位置的正文内容相关，不能为了凑数而添加不相关的引用。**在描述中，所有测试框架名称、测试方法名、配置项等都必须用反引号包裹。",
  "performance_optimization": "性能优化方案（根据实际内容决定长度，通常400-600字）。详细描述系统的性能优化点、优化策略、性能指标等。包含数据库查询优化、缓存策略、前端性能优化、资源加载优化等。**为每个性能优化点、优化策略添加引用标注，内容越详细，引用就应该越多。但必须确保每个引用标注对应的参考文献URL与引用位置的正文内容相关，不能为了凑数而添加不相关的引用。**在描述中，所有优化技术、配置项、工具名称等都必须用反引号包裹。",
  "deployment_config": "部署配置详解（根据实际内容决定长度，通常400-600字）。详细描述生产环境的部署配置、环境变量、配置文件、Docker配置、Nginx配置等。包含详细的配置示例和说明。**为每个部署配置、容器化方案添加引用标注，内容越详细，引用就应该越多。但必须确保每个引用标注对应的参考文献URL与引用位置的正文内容相关，不能为了凑数而添加不相关的引用。**在描述中，所有配置文件名称、配置项、命令、路径等都必须用反引号包裹，例如：在 `docker-compose.yml` 中配置服务，使用 `nginx.conf` 配置反向代理。",
  "mermaid_diagrams": {{
    "architecture": "系统架构图的 Mermaid 代码（可选，如果系统涉及多个组件/服务/层则生成，否则为 null；使用 graph TD 或 graph LR，包含前端、后端、数据库等主要组件及其关系）",
    "data_flow": "数据流图的 Mermaid 代码（可选，如果系统有复杂的数据流转则生成，否则为 null；使用 flowchart，展示数据在各层之间的流转）",
    "deployment": "部署架构图的 Mermaid 代码（可选，如果涉及容器化、多服务器部署等则生成，否则为 null；使用 graph，展示服务器、容器、网络等部署结构）",
    "database_er": "数据库 ER 图的 Mermaid 代码（可选，如果涉及数据库设计且有多个表的关系则生成，否则为 null；使用 erDiagram，展示主要数据表及其关系。重要：字段定义中不要使用 PK、FK、UK 等标记，只写类型和字段名，例如：BIGINT id，VARCHAR username，不要写成 BIGINT id PK 或 BIGINT user_id FK）"
  }},
  "implementation_steps": [
    "第一步：项目初始化与环境搭建（具体说明需要安装的工具、配置的环境等）",
    "第二步：数据库设计与创建（说明数据库表结构设计思路）",
    "第三步：后端开发（说明后端模块开发顺序和关键实现）",
    "第四步：前端开发（说明前端页面和功能开发顺序）",
    "第五步：前后端联调与测试（说明测试策略和方法）",
    "第六步：部署上线（说明部署流程和注意事项）"
  ],
  "key_features": [
    "核心功能特性1（详细描述）",
    "核心功能特性2（详细描述）",
    "核心功能特性3（详细描述）"
  ],
  "references": [
    {{
      "title": "参考文献标题（如：Spring Boot 官方文档）",
      "url": "完整的URL地址（从调研数据中提取）"
    }},
    {{
      "title": "另一个参考文献标题",
      "url": "完整的URL地址"
    }}
  ]
  **references 数组约束（必须严格遵守，这是最重要的约束）**：
  - **一致性约束（必须严格遵守）**：
    * references 数组的长度必须等于正文中使用的最大引用编号（例如：如果正文中最大引用编号是 [34]，则 references 数组必须有且仅有 34 个元素）
    * 如果正文中只使用了 [1] 到 [N]，则 references 数组必须只有 N 个元素，不能包含更多
    * 正文中绝对不能使用超出 references 数组范围的引用标注（例如：如果 references 只有 39 个元素，正文中绝对不能使用 [40]、[53]、[74]、[96]、[98] 或更大的编号）
    * references 数组中绝对不能包含在正文中没有使用的引用编号对应的URL（例如：如果正文中只使用了 [1] 到 [34]，则 references 数组不能包含第 35 个及以后的元素）
    * 禁止添加在正文中没有使用的参考文献
    * 禁止在正文中使用超出 references 数组范围的引用标注
  - **相关性约束（必须严格遵守）**：
    * 每个 references 元素必须对应正文中的一个引用标注，且URL必须与引用位置的正文内容高度相关
    * 在生成 references 数组时，必须确保每个URL的内容都与对应的引用位置正文内容相关（例如：如果正文提到"MySQL 数据库"，引用的URL必须与MySQL相关，不能引用与MySQL无关的URL）
    * 禁止为了满足数量要求而添加与正文内容无关的URL
    * 如果某个引用位置找不到相关的URL，应该减少引用数量，而不是添加不相关的URL
  - **生成流程（必须严格遵守）**：
    1. 先确定要在正文中使用的引用编号范围（如 [1] 到 [N]），确保每个引用标注都与正文内容高度相关
    2. 根据引用编号，从调研数据的URL列表中选择对应的URL，确保每个URL都与引用位置的正文内容相关
    3. 生成 references 数组，确保只有 N 个元素（不多不少），且每个元素对应一个引用编号
    4. 最终验证：references 数组的长度必须等于正文中使用的最大引用编号，且每个URL都与对应的引用位置内容相关
}}

重要提示：
0. **引用标注与参考文献严格一一对应且内容相关（最高优先级约束，必须严格遵守）**：
   - **一致性约束（必须严格遵守）**：
     * **references 数组的长度必须等于正文中使用的最大引用编号**（例如：如果正文中最大引用编号是 [34]，则 references 数组必须有且仅有 34 个元素）
     * **正文中绝对不能使用超出 references 数组范围的引用标注**（例如：如果 references 只有 39 个元素，正文中绝对不能使用 [40]、[53]、[74]、[96]、[98] 或更大的编号）
     * **references 数组中绝对不能包含在正文中没有使用的引用编号对应的URL**（例如：如果正文中只使用了 [1] 到 [34]，则 references 数组不能包含第 35 个及以后的元素）
     * **生成时必须先确定引用编号范围，然后严格按照该范围生成 references 数组**
   - **相关性约束（必须严格遵守）**：
     * **每个引用标注对应的参考文献URL必须与引用位置的正文内容高度相关**，不能为了凑数而添加不相关的引用
     * **在添加引用标注前，必须确认该URL的内容确实与引用位置的正文内容相关**（例如：如果正文提到"Spring Boot 文件上传"，引用的URL必须与Spring Boot文件上传相关，不能引用与文件上传无关的URL）
     * **禁止为了满足数量要求而添加与正文内容无关的引用**，宁可引用数量少，也要保证每个引用都与内容相关
     * **如果某个技术点在调研数据中没有找到相关的URL，不要强行添加不相关的引用**
   - **生成流程（必须严格遵守，缺一不可）**：
     1. **第一步：确定引用编号范围**
        - 先确定要在正文中使用的引用编号范围（如 [1] 到 [N]）
        - 确保每个引用标注都与正文内容高度相关
        - 记录最大引用编号 N
     2. **第二步：选择相关URL**
        - 根据引用编号，从调研数据的URL列表中选择对应的URL
        - **必须确保每个URL的内容与引用位置的正文内容相关**（例如：如果正文提到"HTML5 Audio API"，引用的URL必须与HTML5 Audio API相关）
        - 如果某个引用位置找不到相关的URL，不要强行添加不相关的URL，应该减少引用数量
     3. **第三步：生成 references 数组**
        - 生成 references 数组，确保只有 N 个元素（不多不少）
        - 每个元素对应一个引用编号（[1] 对应 references[0]，[2] 对应 references[1]，以此类推）
        - 确保每个URL都与对应的引用位置内容相关
     4. **第四步：最终验证（必须执行）**：
        - 验证 references 数组的长度必须等于正文中使用的最大引用编号
        - 验证正文中没有使用超出 references 数组范围的引用标注
        - 验证每个引用标注对应的URL都与引用位置的正文内容相关
        - 如果验证失败，必须重新生成，直到满足所有约束
1. 技术栈必须具体到框架/库的名称和版本号（如：Spring Boot 3.2.0，不要只写"Spring Boot"）
2. **必须为每个主要技术选型提供选择理由（*_reason字段），说明为什么选择这个技术，包括其优势、适用场景等**
3. **详细描述部分要求**（根据实际项目需求决定是否包含，**不要强行添加不相关的功能**）：
   - **design_philosophy：必须包含**（根据实际内容决定长度，通常800-1200字），深入阐述设计理念和技术选型理由，采用学术报告风格，使用"首先...其次...再次...最后..."等结构
   - **module_implementation：必须包含**（根据实际内容决定长度，通常800-1500字），详细描述各功能模块的实现细节
   - **architecture_details：必须包含**（根据实际内容决定长度，通常600-1500字），深入阐述系统架构的设计思路
   - **non_functional_requirements：根据项目需求决定**，如果项目有性能、扩展性等要求则详细描述，每个子字段都要有具体的量化指标（如：响应时间<200ms，支持1000并发，99.9%可用性等）。**如果项目是简单的单机应用，可以简要说明原因**（如：本项目为轻量级单机应用，无需考虑大规模扩展性，scalability字段设为null）
   - **security_design：根据项目需求决定**，**如果项目不需要登录认证（如：单机工具、公开访问的应用），则明确说明原因**（如：本项目无需用户登录，故authentication和authorization字段设为null；但需要说明文件上传安全、API安全等基础安全措施）。如果项目涉及用户认证、数据安全等则详细描述，每个安全方面都要有具体的实现方案（如：使用JWT Token，Token有效期24小时，使用HS256算法签名等）
   - **api_design：如果项目有API接口则必须包含**（根据实际内容决定长度，通常600-1000字），包含所有API接口的详细设计规范。**如果项目没有API（如：纯前端静态网站），可以设为null**
   - **database_design：如果项目使用数据库则必须包含**（根据实际内容决定长度，通常800-1200字），必须包含所有数据库表的详细设计，包括完整的表结构定义、字段说明、索引设计、数据字典等。**必须包含完整的建表SQL语句示例**。**如果项目不使用数据库，可以设为null**
   - **error_handling：必须包含**（根据实际内容决定长度，通常600-1000字），必须包含错误处理机制和异常设计的详细说明，包括全局异常处理器、异常分类、错误码设计、错误响应格式、常见错误场景处理、日志记录策略等。**必须包含错误码表或错误响应格式示例**。即使是简单项目也应该有基本的错误处理机制
   - **testing_strategy：建议包含**（根据实际内容决定长度，通常400-600字），包含测试策略和方案。可以根据项目复杂度调整详细程度
   - **performance_optimization：根据项目需求决定**（根据实际内容决定长度，通常400-600字），如果项目有性能要求则详细描述。**如果是简单的单机应用，可以简要说明**（如：本项目为轻量级应用，当前性能已满足需求，暂无需特殊优化，设为null）
   - **deployment_config：如果项目需要部署则建议包含**（根据实际内容决定长度，通常400-600字），包含部署配置详解。如果是纯前端静态网站，可以简要说明部署方式
   
   **重要原则（必须严格遵守）**：
   - **不要为了满足字段要求而强行添加不相关的功能或技术**（如：项目不需要登录，就不要添加JWT Token认证；项目不使用缓存，就不要添加Redis；项目不使用消息队列，就不要添加Kafka或RabbitMQ）
   - **如果某个功能或技术不需要，直接设为null或空数组，不要强行添加**（如：本项目无需用户登录，故authentication设为null；本项目不使用缓存，故cache设为null；本项目不使用消息队列，故不在other数组中添加）
   - **技术栈字段必须真实反映项目实际使用的技术**：
     * 如果项目使用原生JavaScript，frontend.framework设为null，不要强行添加Vue或React
     * 如果项目不使用ORM，backend.orm设为null，不要强行添加MyBatis-Plus或Hibernate
     * 如果项目不使用数据库，database.primary设为null，不要强行添加MySQL或PostgreSQL
     * 如果项目不使用缓存，database.cache设为null，不要强行添加Redis
     * 如果项目不使用容器化，devops.container设为null，不要强行添加Docker
     * 如果项目不使用CI/CD，devops.ci_cd设为null，不要强行添加Jenkins或GitHub Actions
     * 如果项目不使用监控，devops.monitoring设为null，不要强行添加Prometheus
     * 如果项目没有其他技术，other数组设为空数组[]，不要强行添加不需要的技术
   - **根据实际项目需求来决定是否包含某些部分**，优先保证方案的真实性和实用性
   - **所有包含的部分都要详细描述**，采用学术报告风格，使用"首先...其次...再次...最后..."等结构
   - **在描述中，如果提到"不使用"、"不引入"、"无需"某项技术，必须确保技术栈字段中也不包含该技术**
4. **引用要求（内容相关性原则）**：
   - **核心原则**：
     * **内容尽量丰富，引用尽量多**：在内容足够丰富和详细的前提下，鼓励为每个主要技术点、设计决策、实现细节添加引用标注
     * **引用必须与正文内容相关**：每个引用标注对应的参考文献URL必须与引用位置的正文内容相关，不能为了凑数而添加不相关的引用
     * **禁止幻觉和强行引用**：如果某个技术点或概念在调研数据中没有找到相关的URL，不要强行添加不相关的引用
   - **references 数组中的URL来源规则**：
     * **优先使用调研数据开头的URL列表中的URL**（这些是搜索或fetch到的实际URL，最可靠）
     * **如果URL列表中没有足够的相关URL，可以使用你已知的URL**（包括官方文档、技术社区、博客等），但必须是真实存在的URL
     * **不一定要是官方的**：可以使用非官方的技术社区、博客、教程等URL，但必须保证该URL的内容与引用位置的正文内容相关
     * **所有URL必须与用户需求（{requirement}）相关**，不能添加与用户需求无关的URL
     * **如果URL列表中没有足够的相关URL，不要为了满足数量要求而添加不相关的URL**。优先保证质量而非数量
   - **引用添加原则**：
     * **为每个主要技术选型添加引用**：当提到某个框架、库、工具时，如果调研数据中有相关的URL，应该添加引用标注
     * **为每个设计决策添加引用**：当说明为什么选择某个架构模式、设计模式时，如果调研数据中有相关的URL，应该添加引用标注
     * **为每个实现细节添加引用**：当描述具体的实现方式、API设计、配置方法时，如果调研数据中有相关的URL，应该添加引用标注
     * **内容越详细，引用就应该越多**：如果某个部分内容非常详细（包含多个技术点、多个设计决策、多个实现细节），就应该为每个技术点添加相应的引用
     * **不要强行凑数**：如果某个部分内容简单，或者某个技术点在调研数据中没有找到相关的URL，就不要强行添加不相关的引用
   - **重要约束**：
     * **内容优先**：先确保内容足够丰富和详细，再根据内容添加相应的引用
     * **相关性优先**：每个引用标注对应的参考文献URL必须与引用位置的正文内容相关，不能为了凑数而添加不相关的引用
     * **禁止幻觉**：禁止编造不存在的URL，禁止添加与正文内容无关的引用
     * **鼓励多引用**：在内容足够丰富的前提下，鼓励为每个技术点添加引用，引用数量可以很多（如20-50个或更多），但必须确保每个引用都与内容相关且真实存在
   - 引用应该涵盖：官方文档、最佳实践、性能指南、安全指南、部署方案、设计模式、架构模式、技术选型对比等各个方面
   - **引用来源多样化且优先级平等**：**所有引用来源（包括官方文档、技术社区、博客等）都具有同等价值，官方文档不应有更高优先级**。应该根据内容质量、相关性和实用性选择引用，而不是根据来源类型。以下平台都是优秀的引用来源：
     * **通用技术社区**：CSDN、掘金、博客园、思否（SegmentFault）、开源中国、V2EX
     * **知识沉淀与问答**：知乎（技术专栏和深度回答，适合技术选型、趋势分析、架构设计思考）、Stack Overflow（中文讨论部分）
     * **大厂技术门户**：阿里技术、腾讯技术、字节跳动技术、美团技术、京东技术等官方技术博客和公众号（适合大规模分布式系统、高并发、AI/数据技术等实战经验）
     * **云平台文档社区**：阿里云、腾讯云、华为云、百度智能云等文档和最佳实践（适合云原生、Kubernetes、数据库服务、中间件等基础设施）
     * **代码托管平台**：GitHub、Gitee（码云）、GitCode（适合开源项目、实战代码、本地化解决方案）
     * **垂直领域社区**：Go语言中文网、Rust CN社区、Python之家、Vue.js中文社区、React中文社区等（适合特定语言/框架的深度研究和最佳实践）
   - **每个主要技术选型都应该有对应的引用标注**，优先选择内容质量高、实战经验丰富且与用户需求相关的文章，无论来源是官方文档还是技术社区
5. **non_functional_requirements（非功能性需求）要求**：
   - **根据项目实际需求决定是否包含**，如果项目有性能、扩展性等要求则详细描述
   - 每个子字段都要有具体的量化指标或明确的描述（如：响应时间<200ms，支持1000并发，99.9%可用性等）
   - **如果包含多个方面的详细描述，建议每个子字段包含1-2个引用标注**；如果某些方面不适用或内容简单，则相应减少引用
   - **引用数量应该与内容深度匹配**，不要为了达到数量而强行添加不相关的引用
   - **如果项目是简单的单机应用，某些方面不适用，可以简要说明原因并设为null**（如：本项目为轻量级单机应用，无需考虑大规模扩展性，scalability字段设为null）
   - **重要：设为null的字段不会在最终生成的文档中显示**，所以如果某个功能不需要，直接设为null即可，不需要在文档中说明原因
6. **security_design（安全设计）要求**：
   - **根据项目实际需求决定是否包含各个字段**，**不要为了满足字段要求而强行添加不相关的功能**
   - **如果项目不需要登录认证（如：单机工具、公开访问的应用），则明确说明原因**（如：本项目无需用户登录，故authentication和authorization字段设为null；但需要说明文件上传安全、API安全等基础安全措施）
   - **重要：设为null的字段不会在最终生成的文档中显示**，所以如果某个功能不需要，直接设为null即可，不需要在文档中说明原因
   - **如果项目涉及用户认证、数据安全等则详细描述**，每个安全方面都要有具体的实现方案（如：使用JWT Token，Token有效期24小时，使用HS256算法签名等）
   - **如果包含多个安全方面的详细描述，建议每个子字段包含1-2个引用标注**；如果某些方面不适用或内容简单，则相应减少引用
   - **引用数量应该与内容深度匹配**，不要为了达到数量而强行添加不相关的引用
   - 如果项目不涉及某些安全方面（如合规性），compliance 字段可以设为 null
   - **引用来源**：**所有安全相关的引用来源优先级平等**，包括但不限于：
     * OWASP、CWE、安全框架官方文档等权威安全资源
     * CSDN、掘金、博客园、思否、知乎等技术社区中的安全实践文章（往往包含更多实战案例和具体实现细节）
     * 大厂技术博客中的安全架构设计文章
     * GitHub、Gitee 上的安全相关开源项目和最佳实践
     * **优先选择内容质量高、实战价值强的文章，无论来源类型**
7. **引用标注与参考文献严格一一对应且内容相关（这是最重要的约束，必须严格遵守）**：
   - **在详细描述中必须使用引用标注**，如 [1]、[2]、[3] 等，这些数字对应 references 数组的索引（从1开始，不是从0开始）
   - **一致性约束（必须严格遵守）**：
     * **references 数组必须只包含在正文中实际使用的引用编号对应的URL**
     * **如果正文中只使用了 [1] 到 [N]，那么 references 数组必须只有 N 个元素，不能包含更多**
     * **绝对不能出现正文中没有对应引用标注的参考文献**（例如：正文中只到 [34]，但 references 有 70 个元素，这是错误的）
     * **绝对不能出现正文中使用了超出 references 数组范围的引用标注**（例如：正文中使用了 [74]，但 references 只有 39 个元素，这是绝对错误的，必须避免）
   - **相关性约束（必须严格遵守）**：
     * **每个引用标注都必须与引用位置的正文内容高度相关**：
       - 引用标注应该紧跟在相关技术名称或概念之后
       - 每个引用标注对应的参考文献URL必须与引用位置的正文内容高度相关（例如：如果正文提到"HTML5 Audio API"，引用的URL必须与HTML5 Audio API相关，不能引用与Audio API无关的URL）
       - **禁止为了凑数而添加与正文内容无关的引用标注和参考文献**
       - **在添加引用标注前，必须确认该URL的内容确实与引用位置的正文内容相关**
     * **如果某个技术点在调研数据中没有找到相关的URL，不要强行添加不相关的引用**，应该减少引用数量
   - **生成流程（必须严格遵守，缺一不可）**：
     1. **第一步：确定引用编号范围**
        - 先确定要在正文中使用的引用编号范围（如 [1] 到 [N]）
        - 确保每个引用标注都与正文内容高度相关
        - 记录最大引用编号 N
     2. **第二步：选择相关URL**
        - 根据引用编号，从调研数据的URL列表中选择对应的URL
        - **必须确保每个URL的内容与引用位置的正文内容相关**（例如：如果正文提到"Spring Boot 文件上传"，引用的URL必须与Spring Boot文件上传相关）
        - 如果某个引用位置找不到相关的URL，不要强行添加不相关的URL，应该减少引用数量
     3. **第三步：生成 references 数组**
        - 生成 references 数组，确保只有 N 个元素（不多不少）
        - 每个元素对应一个引用编号（[1] 对应 references[0]，[2] 对应 references[1]，以此类推）
        - 确保每个URL都与对应的引用位置内容相关
     4. **第四步：验证一致性**
        - 确保正文中使用的每个引用编号 [X] 都有对应的 references[X-1]（因为数组索引从0开始）
        - references 数组的长度必须等于正文中使用的最大引用编号（例如：如果正文中最大引用编号是 [34]，则 references 数组必须有且仅有 34 个元素）
     5. **第五步：验证相关性**
        - 验证每个引用标注对应的URL都与引用位置的正文内容相关
        - 如果发现不相关的引用，必须重新生成，直到满足相关性要求
   - **references 数组中的URL来源规则**：
     * **优先使用调研数据开头的URL列表中的URL**（搜索或fetch到的实际URL）
     * **如果URL列表中没有足够的相关URL，可以使用你已知的官方文档URL**（如Spring Boot官方文档、Vue.js官方文档、MySQL官方文档等）
     * **可以使用你已知的标准规范、最佳实践指南的官方URL**（如RESTful API规范、HTTP标准、OWASP安全指南等）
     * **禁止编造不存在的URL**，只能使用真实存在的官方文档、标准规范、技术社区等URL
   - 每个引用对象必须包含 title 和 url 字段
   - **生成时，先确定正文中要使用的引用编号（如 [1] 到 [N]），然后只生成对应数量的 references 元素**
9. **引用标注的使用规则（必须严格遵守）**：
   - **引用标注必须与正文内容高度相关**：
     * 当提到某个技术或概念时，如果调研数据开头的URL列表中有相关的URL，可以添加引用标注
     * **引用标注应该紧跟在相关技术名称或概念之后**，如：Spring Boot 3.2.0 [1]
     * **每个引用标注对应的参考文献URL必须与引用位置的正文内容高度相关**，不能为了凑数而添加不相关的引用
     * **在添加引用标注前，必须确认该URL的内容确实与引用位置的正文内容相关**（例如：如果正文提到"MySQL 数据库"，引用的URL必须与MySQL相关，不能引用与MySQL无关的URL）
   - **所有引用的URL必须与用户需求（{requirement}）相关**，不能引用与用户需求无关的URL
   - 每个引用标注都必须有对应的URL在 references 中
   - references 数组中的索引从1开始，所以 [1] 对应 references[0]，[2] 对应 references[1]，以此类推
   - **一致性约束（必须严格遵守）**：
     * **references 数组的长度必须等于正文中使用的最大引用编号**（例如：如果正文中最大引用编号是 [34]，则 references 数组必须有且仅有 34 个元素）
     * **正文中绝对不能使用超出 references 数组范围的引用标注**（例如：如果 references 只有 39 个元素，正文中绝对不能使用 [40]、[53]、[74]、[96]、[98] 或更大的编号）
     * **references 数组中不能包含在正文中没有使用的引用编号对应的URL**（例如：如果正文中只使用了 [1] 到 [34]，则 references 数组不能包含第 35 个及以后的元素）
   - **相关性约束（必须严格遵守）**：
     * **每个引用标注对应的参考文献URL必须与引用位置的正文内容高度相关**
     * **禁止为了满足数量要求而添加与正文内容无关的引用**
     * **如果某个技术点在调研数据中没有找到相关的URL，不要强行添加不相关的引用**，应该减少引用数量
   - **引用来源选择原则**：
     * **优先使用调研数据开头的URL列表中的URL**（搜索或fetch到的实际URL）
     * **如果URL列表中没有足够的相关URL，可以使用你已知的官方文档URL**（如框架官方文档、数据库官方文档等）
     * **可以使用你已知的标准规范、最佳实践指南的官方URL**（如RESTful API规范、HTTP标准、OWASP安全指南等）
     * **禁止编造不存在的URL**，只能使用真实存在的URL
     * **所有引用来源优先级平等**，应该根据内容质量、相关性和实用性选择引用，而不是根据来源类型
     * **最重要的是确保引用的URL与用户需求相关，并且是真实存在的URL**
     * 以下平台都是优秀的引用来源：
     * 中文技术社区（CSDN、掘金、博客园、思否、知乎、V2EX等）的文章往往包含更多实战经验、本地化最佳实践和具体实现细节，应该充分利用
     * 大厂技术博客（阿里、腾讯、字节等）适合引用大规模系统架构、高并发处理、工程实践等
     * 云平台文档（阿里云、腾讯云等）适合引用云原生、容器化、中间件等基础设施方案
     * GitHub、Gitee、GitCode 上的开源项目和代码示例适合引用具体实现方案
     * 垂直领域社区（Go中文网、Rust CN等）适合引用特定技术的深度研究和最佳实践
     * 官方文档、技术博客、最佳实践指南等也是很好的引用来源
     * **选择引用时，优先考虑内容质量、实战价值、与用户需求的相关性，以及是否在URL列表中，而不是来源类型或数量要求**
10. **Mermaid 图表要求**（可选，根据项目复杂度决定）：
   - architecture: 如果项目涉及多个组件/服务/层（如：前端、后端、数据库、缓存、消息队列），建议生成架构图；如果项目非常简单（如：单页面静态网站），可以不生成（设为 null）
   - data_flow: 如果系统有复杂的数据流转（如：用户请求 → API → 业务层 → 数据层 → 缓存），建议生成数据流图；如果只是简单的 CRUD，可以不生成（设为 null）
   - deployment: 如果涉及容器化部署、多服务器、负载均衡等，建议生成部署架构图；如果只是单机部署，可以不生成（设为 null）
   - database_er: 如果涉及数据库设计且有多个表的关系，建议生成 ER 图；如果只有单个表或没有数据库，可以不生成（设为 null）
   - **ER 图语法要求**：
     * 关系定义使用标准语法：ENTITY1 ||--o{{ ENTITY2 : "label"
     * 字段定义格式：类型 字段名（例如：BIGINT id，VARCHAR username）
     * **禁止使用 PK、FK、UK 等标记**（Mermaid 不支持这些标记，会导致语法错误）
     * 字段类型可以简化（例如：VARCHAR 而不是 VARCHAR(50)）
   - **图表内容必须与技术选型完全一致**（这是最重要的约束）：
     * 在生成任何图表前，必须仔细检查 tech_stack、design_philosophy 和 architecture 部分中明确说明的技术选型决策
     * **如果 tech_stack 中某项技术设为null或空数组，则图表中绝对不能包含该技术组件**
     * 如果方案正文中明确说明"不使用"、"不引入"、"无需"某项技术（如 Redis、WebSocket、消息队列、缓存层等），则图表中绝对不能包含该技术组件
     * 图表只能包含实际采用的技术栈组件，不能盲目添加常见但未选用的技术组件
     * 例如：如果 tech_stack.database.cache 设为null，则架构图、数据流图、部署架构图中都不能出现Redis或任何缓存组件
     * 例如：如果正文说明"系统不引入Redis缓存层，因单机应用无需高性能读写加速"，则架构图、数据流图、部署架构图中都不能出现Redis
     * 例如：如果正文说明"因无实时通信需求，故未启用WebSocket"，则系统架构图中不能包含WebSocket服务
     * 例如：如果 tech_stack.devops.container 设为null，则部署架构图中不能包含Docker或Kubernetes
     * 图表必须真实反映设计方案的实际架构，与方案描述和技术栈字段保持100%一致
   - 所有 Mermaid 代码必须是有效的、可以直接渲染的代码
   - 使用标准的 Mermaid 语法，确保图表清晰易读
   - 如果某个图表不适用，必须设为 null（不要设为空字符串）
11. **Markdown 格式要求（非常重要）**：
    - **所有代码片段、HTML标签、方法名、API路径、类名、配置项、技术术语等都必须用反引号包裹**
    - HTML标签示例：使用 `<input type='file' accept='audio/*'>` 而不是 <input type='file' accept='audio/*'>
    - 方法名示例：调用 `isEmpty()` 判断是否为空，通过 `getContentType()` 校验 MIME 类型
    - API路径示例：发送 POST 请求至 `/api/songs/upload`，调用 `GET /api/songs` 接口
    - 类名和注解示例：使用 `@RequestParam("file") MultipartFile file` 接收文件
    - 技术术语示例：通过 `FormData` 封装数据，使用 `Math.random()` 生成随机索引
    - 配置项示例：在 `application.yml` 中配置 `spring.servlet.multipart.max-file-size=10MB`
    - 数据库相关：`song_info` 表、`id` 字段、`BIGINT` 类型等
    - **这是 Markdown 格式规范，必须严格遵守，确保生成的文档中所有代码和技术术语都能正确显示**
12. 实施步骤要具体可执行，不要过于抽象
13. 关键词要准确反映项目的技术特点和业务领域
14. 不要输出 ```json 代码块标记，直接输出纯 JSON 字符串
15. 确保所有必填字段都有值，可选字段如果不适用则设为 null
16. **references 数组中的每个对象必须包含 title 和 url 字段，不能为空**
16. **参考文献URL来源说明**：
    - **优先使用调研数据开头的URL列表**（这些是搜索或fetch到的实际URL，最可靠）
    - **如果URL列表中没有足够的相关URL，可以使用你已知的URL**（包括官方文档、技术社区、博客、教程等），但必须满足以下条件：
      * **必须是真实存在的URL**，禁止编造不存在的URL
      * **必须保证该URL的内容与引用位置的正文内容相关**，不能为了凑数而添加不相关的URL
      * **不一定要是官方的**：可以使用非官方的技术社区（如CSDN、掘金、博客园、思否、知乎等）、博客、教程等URL，只要该URL的内容与引用位置的正文内容相关即可
    - **URL来源示例**（不限于这些，任何真实存在且内容相关的URL都可以使用）：
      * 官方文档：Spring Boot官方文档、Vue.js官方文档、MySQL官方文档等
      * 技术社区：CSDN、掘金、博客园、思否、知乎、Stack Overflow等
      * 大厂技术博客：阿里技术、腾讯技术、字节跳动技术、美团技术等
      * 云平台文档：阿里云、腾讯云、华为云等
      * 代码托管平台：GitHub、Gitee、GitCode等
      * 标准规范：RESTful API设计规范、HTTP标准、OWASP安全指南等
    - **所有URL必须与用户需求相关**，不能添加与用户需求无关的URL
    - **每个引用标注对应的参考文献URL必须与引用位置的正文内容相关**，不能为了凑数而添加不相关的引用
"""
)